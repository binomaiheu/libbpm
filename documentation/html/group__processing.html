<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libbpm: BPM Processing Routines</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>BPM Processing Routines</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="anchor" name="proc"></a><p>
This set of routines contains the BPM digitised waveform processing routines to go from a sis digitised waveform to position and slope information.<h2><a class="anchor" name="proc_structure">
General structure of the BPM signal processing</a></h2>
The BPM signal processing algorithms are centered around a few top-level routines which need to called by a standard user. All make use of a number of BPM data structures which hold BPM configuration data ( bpmconf_t ), processed BPM information ( bpmproc_t ) or BPM calibration information ( bpmcalib_t ). As the BPM processing algorithms make extensive use of the bpmdsp module, the BPM signals need to be encapsulated in a <a class="el" href="structdoublewf__t.html">doublewf_t</a> waveform before feeding them to these processing routines. The top-level processing routines have a mode bitword which provides some processing options that the user can feed into the processing algorithm.<h3><a class="anchor" name="proc_structure_diode">
Diode signal processing</a></h3>
Since the idea was to unify the processing into one coherent set of data structures, the diode or trigger information had to be fitted into the same framework as the BPM data. This is the function call :<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> <a class="code" href="group__processing.html#g64dcc54dd58051ed9183a44b791ed73b">process_diode</a>( <a class="code" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="code" href="structbpmconf.html">bpmconf_t</a> *conf, <a class="code" href="structbpmproc.html">bpmproc_t</a> *proc );
</pre></div><p>
So the diode pulse has to be fitted into a <a class="el" href="structdoublewf__t.html">doublewf_t</a> along with a bpmconf_t structure conf. The routine first checks the flag <a class="el" href="structbpmconf.html#6360d70b5d4f4abfb37ca7e38df5b5ed">bpmconf_t::cav_type</a> for the cavity type. This should be of type diode for the routine to proceed. It then calls the fit_diodepulse routine onto the signal, which returns the fitted t0 into the bpmproc_t structure as proc-&gt;t0.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Note that there is the possibility to abuse a dipole or monopole signal as a trigger pulse. In this case the process_diode routine will determine the RMS of the noise in front of the digitised dipole/monopole signal (first 20 samples ) and return the timestamp in <a class="el" href="structbpmproc.html#882cae0e540fd6d8557628a7edcb449d">bpmproc_t::t0</a> of the first sample which is 10 times largers than this RMS value. For this behaviour, the <a class="el" href="structbpmconf.html#6360d70b5d4f4abfb37ca7e38df5b5ed">bpmconf_t::cav_type</a> setting is irrelevant but the <a class="el" href="structbpmconf.html#2a7324686323fe06ecbe81a6455e9d6f">bpmconf_t::forced_trigger</a> value has to be set to 1. Note that this behaviour is normally not needed an for experimental purposes only. </dd></dl>
<h3><a class="anchor" name="proc_structure_monopole">
Monopole signal processing</a></h3>
For monopole cavities one only needs to determine the amplitude and phase, so no post-processing to get to position and slope using a reference cavity and calibration information is needed. Therefore the process_monopole routine is basically a wrapper around the process_waveform routine which does exactly this determination of the amplitude and phase. The function call is :<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> <a class="code" href="group__processing.html#g4d159862631514e412a0f30e278e9426">process_monopole</a>( <a class="code" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="code" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="code" href="structbpmproc.html">bpmproc_t</a> *proc, 
                          <a class="code" href="structbpmproc.html">bpmproc_t</a> *trig, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode );
</pre></div><p>
This routine basically is a wrapper around<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> <a class="code" href="group__processing.html#gbd8d3c45cc42c393a13e1471b1dac2c2">process_waveform</a>( <a class="code" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="code" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="code" href="structbpmproc.html">bpmproc_t</a> *proc, 
                          <a class="code" href="structbpmproc.html">bpmproc_t</a> *trig, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode );
</pre></div><p>
and handles all the processing steps flagged by the mode bitword. Chronologically it executes the following steps :<p>
<ul>
<li>Check whether the waveform was saturated or not. This is done by a call to check_saturation, which needs the <a class="el" href="structdoublewf__t.html">doublewf_t</a> signal obviously and the ADC resolution set by the number of bits in <a class="el" href="structbpmconf.html#4590775f30535e00c5ec47c0f9c138ec">bpmconf_t::digi_nbits</a>. It returns whether the waveform was saturated ( saved in <a class="el" href="structbpmproc.html#611e04c6377faf4db9eb24a4edc1ac3f">bpmproc_t::saturated</a> ) and assigns the sample number of the first unsaturated sample in the waveform to <a class="el" href="structbpmproc.html#714ac2e4b3b26339aae97a0e5b32a300">bpmproc_t::iunsat</a>.</li></ul>
<p>
<ul>
<li>Then process_waveform goes on with subtracting the pedestal of the waveform by getting the average and RMS of the first 20 samples in the waveform using get_pedestal and storing the results in <a class="el" href="structbpmproc.html#3be3f5398b06d6bb81f3fee29b6b904a">bpmproc_t::voltageoffset</a> and <a class="el" href="structbpmproc.html#03a2fb57c6fdaa5ea8558235bf69e5b2">bpmproc_t::ampnoise</a>. It subsequently subtracts this voltage offset from each sample in the waveform.</li></ul>
<p>
<ul>
<li>Then the t0 time is set. If the process_waveform has trigger information available in the form of a bpmproc_t trigger argument wich was handled by process_diode, then the routine will assume this information has to be used as t0 and will copy the trigger-&gt;t0 value to it's own <a class="el" href="structbpmproc.html#882cae0e540fd6d8557628a7edcb449d">bpmproc_t::t0</a>. If a bpmproc_t trigger argument is not available ( NULL pointer ), the process_waveform routine will assume the t0 has been set fixed by the BPM configuration ( external clocking ) and will use and copy the <a class="el" href="structbpmconf.html#59157c2831c6191ccabfc702acddf02a">bpmconf_t::t0</a> to it's <a class="el" href="structbpmproc.html#882cae0e540fd6d8557628a7edcb449d">bpmproc_t::t0</a> value. The <a class="el" href="structbpmproc.html#882cae0e540fd6d8557628a7edcb449d">bpmproc_t::t0</a> is furtheron used in the rest of the processing as the starting time for this cavity signal.</li></ul>
<p>
<ul>
<li>If the PROC_DO_FFT flag has been set in the mode bitword, the process_waveform routine will compute the waveform FFT by calling fft_waveform from the bpmdsp module and storing the result in <a class="el" href="structbpmproc.html#c6f3c265a080e664e10cc6f2339662a7">bpmproc_t::ft</a>. If this is succesfull, the code will go on to check whether this fourier transform needs to be fitted for it's frequency and decay time ( Lorentz line width ). This is done by calling fit_fft. <dl class="attention" compact><dt><b>Attention:</b></dt><dd>This routine is a little experimental and can easily by replaced by the user with some other package e.g. ROOT. The full complex fourier waveform is available in the <a class="el" href="structbpmproc.html#c6f3c265a080e664e10cc6f2339662a7">bpmproc_t::ft</a> as a <a class="el" href="structcomplexwf__t.html">complexwf_t</a>. </dd></dl>
</li><li>If the PROC_DO_FIT flag has been set in the mode bitword, the process_waveform routine will try to fit a decaying sinewave to the waveform, attempting to extract amplitude, phase, frequency and decay time. <dl class="attention" compact><dt><b>Attention:</b></dt><dd>This routine is quite experimental as well and needs proper checking before it can be used stabily ! I recommend using a proper fitting package such as MINUIT to fit the waveforms to a decaying sine wave.</dd></dl>
</li><li>If the PROC_DO_DDC flag has been set in the mode bitword, the process_waveform routine will perform the digital downconversion on the waveform. As this is a more complex algorithm, we will go into a bit more detail here.<ul>
<li>First, we have to tell the DDC algoritm where to get it's frequency and decay time from. By default the algorithm will use in both cases the frequency and decay time which are set in the cavities configuration, being <a class="el" href="structbpmconf.html#6c054672fa971d58fd3c50040d9a7e57">bpmconf_t::ddc_freq</a> and <a class="el" href="structbpmconf.html#626f42b1ed03ecc448dbf6a64852f793">bpmconf_t::ddc_tdecay</a>. However, if the flag(s) PROC_DDC_FITFREQ and/or PROC_DDC_FITTDECAY is/are present and the fits ( see previous item ) were succesfull, the ddc algorithm will use the fitted frequency and decaytime values. Alternatively, if the flag(s) PROC_DDC_FFTFREQ and/or PROC_DDC_FFTTDECAY are/is present, the ddc algoritm will use the frequency and decay time derived from the fitted lorentz lineshape of the waveforms fourier transform.</li></ul>
</li></ul>
<p>
<ul>
<li>Next the DDC algoritm handls the saturation if present ( was set by the <a class="el" href="structbpmproc.html#611e04c6377faf4db9eb24a4edc1ac3f">bpmproc_t::saturated</a> ) flag already. If the waveform was saturated, we will shift the position of the sample time to the last unsaturated sample. <dl class="attention" compact><dt><b>Attention:</b></dt><dd>Since people haven't converged on a proper way to handle saturation, this is a bit of an open point in the code. At the moment, the ddc_tSample is set to the last unsaturated sample, but one should take into account somehow the bandwidth of the DDC filter, which is not done. I've left it as it is, with the wise advice to store the <a class="el" href="structbpmproc.html#611e04c6377faf4db9eb24a4edc1ac3f">bpmproc_t::saturated</a> flag into the user data and simply cut away those pulses.</dd></dl>
If no saturation is present, the sampling point (expressed in time-units, not sampled ) of the DDC algoritm is set to the t0 time ( starting point of the waveform ) + a constant time offset, which can be tweaked in optimisation. <div class="fragment"><pre class="fragment">         proc-&gt;ddc_tSample = proc-&gt;t0 + bpm-&gt;ddc_tOffset;
</pre></div></li></ul>
<p>
<ul>
<li>After the sampling time has been calculated in the previous step, it is converted into a sample number and stored in <a class="el" href="structbpmproc.html#c0632d46a0208577c352ea34bb69d983">bpmproc_t::ddc_iSample</a>.</li></ul>
<p>
<ul>
<li>Then the real downconversion is done, by default libbpm will try to use the optimised ddc_sample_waveform routine to save CPU cycles, but if the full DDC is requested by the mode flag PROC_DDC_FULL, it will go through the entire waveform and convert it to DC using the frequency set as explained previously. The routine that is called is ddc_waveform which basically needs the the pedestal subtraced <a class="el" href="structdoublewf__t.html">doublewf_t</a> waveform, the frequency of downconversion, a 2 omega filter, defined by a <a class="el" href="structfilter__t.html">filter_t</a> structure having the correct type (lowpass) and bandwidth already define and stored in <a class="el" href="structbpmconf.html#641616863daef1ba61c3962ee0f1feb3">bpmconf_t::ddc_filter</a>. The full complex downconverted waveform is stored in the case of full ddc in <a class="el" href="structbpmproc.html#64c8db22258e28f24d7db38244b5df98">bpmproc_t::dc</a>. The amplitude and phase are calculated at the t0 time by extrapolating the phase and amplitude back from the sampling point at <a class="el" href="structbpmproc.html#c0632d46a0208577c352ea34bb69d983">bpmproc_t::ddc_iSample</a>. The ddc_sample_waveform returns these values directly, but does it internally by extrapolation from the sampling time as well, one therefore needs to provide t0, tdecay and iSample as additional arguments to ddc_sample_waveform compared to ddc_waveform.</li></ul>
<p>
<ul>
<li>After this is done, the determined phase is normalised in between 0 and 2pi.</li></ul>
<h3><a class="anchor" name="proc_structure_dipole">
Dipole signal processing</a></h3>
Dipole cavity waveforms first need to undergo the same processing step as monopole waveforms, to determine their phase and amplitude. After that position and slope information need to be determined using the calibration information. The routine<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> <a class="code" href="group__processing.html#g7263f2231c573bf98d41dbaab82c01be">process_dipole</a>( <a class="code" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="code" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="code" href="structbpmcalib.html">bpmcalib_t</a> *cal, <a class="code" href="structbpmproc.html">bpmproc_t</a> *proc, 
                        <a class="code" href="structbpmproc.html">bpmproc_t</a> *trig, <a class="code" href="structbpmproc.html">bpmproc_t</a> *ampref, <a class="code" href="structbpmproc.html">bpmproc_t</a> *phaseref, 
                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode );
</pre></div><p>
is therefore a wrapper around the following two core routines :<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> <a class="code" href="group__processing.html#gbd8d3c45cc42c393a13e1471b1dac2c2">process_waveform</a>( signal, bpm, proc, trig, mode );
    <span class="keywordtype">int</span> <a class="code" href="group__processing.html#g12b153af4b09cd59e863cef0bf5114c3">postprocess_waveform</a>( bpm, proc, cal, ampref, phaseref, mode );
</pre></div><p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>If the PROC_CORR_GAIN (or PROC_CORR_AMP, PROC_CORR_PHASE) flag is set in the mode word, the process_dipole routine will correct the gains based upon the latest calibration tone information stored in the <a class="el" href="structbpmproc.html#e3b787a2ed21acdf52ad9b667f57976e">bpmproc_t::ddc_ct_amp</a> etc variables and comparing them to the <a class="el" href="structbpmcalib.html#f5d9554311f52697ee793de6a14efb9c">bpmcalib_t::ddc_ct_amp</a> at the time of calibration. This is done by a call to correct_gain</dd></dl>
The process_waveform is explained under the process_monopole cavity, the postprocess_waveform routine executes the following :<p>
<ul>
<li>Firstly the routine calculates the I and Q for the dipole cavity from the amplitude and phase references. This is done by a call to get_IQ, and the values are stored in <a class="el" href="structbpmproc.html#5c38241ca4aa400c93988106e8325d74">bpmproc_t::ddc_Q</a>, <a class="el" href="structbpmproc.html#0f0ce52541c5965067e05669dbe96e5d">bpmproc_t::ddc_I</a> for the DDC information and <a class="el" href="structbpmproc.html#ad1d52ffea6d3a39b6e0d672c693ae36">bpmproc_t::fit_Q</a>, <a class="el" href="structbpmproc.html#59924e30e71461ad0a2146a0be873bdf">bpmproc_t::fit_I</a> for the fitted information.</li></ul>
<p>
<ul>
<li>For dipole cavities, the real phase information that means anything is the phase difference between the reference cavity and the dipole cavity. This get's stored into <a class="el" href="structbpmproc.html#f2a86e422e93b453b91206abccc0b351">bpmproc_t::ddc_phase</a> and/or <a class="el" href="structbpmproc.html#eb36a2ab357ca13c3c8352feb8cb6e8d">bpmproc_t::fit_phase</a>. If the flag PROC_RAW_PHASE is set in the mode word, this is skipped.</li></ul>
<p>
<ul>
<li>Using the I and Q information, the position and slope are calculated</li></ul>
<h2><a class="anchor" name="proc_flow">
Processing flow</a></h2>
The question now is how to organise the processing flow from the digitised waveform data. Before being able to obtain positions and slopes, the user will need to have processed all the trigger ( diode ) pulses. And thereafter the monopole waveforms in the event. After that positions and slopes can be calculted using the process_diopole routine. Note that the monopole waveforms depend on the trigger information in the case of internal triggering using a trigger pulse, so a good way to proceed is first to all the trigger pulses, than all the monopole pulses and then all the dipole waveforms.<p>
Alternatively the user can first use the routine process_waveform on all of the waveforms ( together with processing the trigger information ). After this is done, the user can use the postprocess_waveform routine to perform the post-processing on the dipole waveforms.<h2><a class="anchor" name="proc_timing">
About trigger pulses, internal vs. external clock</a></h2>
The SIS ADCs can be triggered by using an external clock in which case all the modules in the system are synchronised and no trigger pulses are needed. Because of the way the processing is setup in process_waveform, the user has to be mindfull of a number of things depending on whether the ADC modules are triggered internally ( and a trigger pulse is available ) or whether they are triggered externally, synchronised to the beam clock, in which case the starting time ( t0 ) of the pulses should be constant for each individual BPM signal.<h3><a class="anchor" name="proc_timing_ext">
External clock triggering</a></h3>
In this case, the t0 should be set in the BPM configuration under <a class="el" href="structbpmconf.html#59157c2831c6191ccabfc702acddf02a">bpmconf_t::t0</a>. During the processing this value will be used and copied to <a class="el" href="structbpmproc.html#882cae0e540fd6d8557628a7edcb449d">bpmproc_t::t0</a>. The bpmconf_t::tOffset defines the offset from this t0 of the pulse of the sampling point in the waveform such that <div class="fragment"><pre class="fragment">    proc-&gt;ddc_tSample = proc-&gt;t0 + bpm-&gt;ddc_tOffset;
</pre></div> This mode will be assumed automatically in the absence of the 4th argument of process_waveform ( bpmproc_t *trig = NULL ).<h3><a class="anchor" name="proc_timing_int">
Internal clock triggering</a></h3>
There the <a class="el" href="structbpmconf.html#59157c2831c6191ccabfc702acddf02a">bpmconf_t::t0</a> value is ignored and no t0 value needs to be specified before hand since it will be fitted from the diode/trigger pulse. In this case the 4th argument of process_waveform needs to be present. Also,<b>the bpmconf_t::tOffset keeps it's definition exaclty the same as in the external clock case</b>. It is the time difference between the sample time and the starttime of the waveform t0, which in this case got fit instead of being fixed.<h2><a class="anchor" name="Incorporating">
calibration tone information</a></h2>
The calibration tone information is kept in two locations. Firstly at the time of calibration, the user should make sure that the latest calibration tone information is set in the bpmcalib_t structure under <a class="el" href="structbpmcalib.html#f5d9554311f52697ee793de6a14efb9c">bpmcalib_t::ddc_ct_amp</a> and <a class="el" href="structbpmcalib.html#2af30b1158dc11d6a7dba61e52b5d11c">bpmcalib_t::ddc_ct_phase</a> and analoguous for the parameters for the fitted processing. Than each time a calibration tone pulse is encountered, the user should pass the phase and amplitude of the calibration tone on to the <a class="el" href="structbpmproc.html#e3b787a2ed21acdf52ad9b667f57976e">bpmproc_t::ddc_ct_amp</a> and <a class="el" href="structbpmproc.html#5461033608c7c42d900d25b7ead44153">bpmproc_t::ddc_ct_phase</a> and therefore always keep the lateste calibration tone information in this location. Each call to<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> <a class="code" href="group__processing.html#gfbefcc42457d943c215b3a423540a145">correct_gain</a>( <a class="code" href="structbpmproc.html">bpmproc_t</a> *proc, <a class="code" href="structbpmcalib.html">bpmcalib_t</a> *cal, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode )
</pre></div><p>
then corrects the phase and amplitude of the current pulse by scaling the amplitude with the ratio between the caltone amplitude at the time of calibration and the lastest one and shifting the phase by the phase difference between the phase of the calibration tone at the time of BPM calibration and the latest phase recorded in the <a class="el" href="structbpmproc.html#5461033608c7c42d900d25b7ead44153">bpmproc_t::ddc_ct_phase</a> variable ( or <a class="el" href="structbpmproc.html#047ed884dc6bc77d4829d83176943ef1">bpmproc_t::fit_ct_phase</a> ).<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>I've include a mode bitword, which takes the flags PROC_CORR_GAIN to correct both amplitude and phase, and PROC_CORR_AMP, PROC_CORR_PHASE to correct only one parameter individually. This is done since e.g. for internal clocking, when the ADC's are not synchronised to each other, it is not really clear where to sample the waveform unless a trigger is supplied in the ADC. For external synchronized clocking, we can just give a fixed sample number, stored in the bpm configuration under <a class="el" href="structbpmconf.html#22293d75805cdba7799374a11ec3efc7">bpmconf_t::ddc_ct_iSample</a>.</dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpm__process_8h.html">bpm_process.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">libbpm main processing routines <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="check__saturation_8c.html">check_saturation.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="correct__gain_8c.html">correct_gain.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ddc__sample__waveform_8c.html">ddc_sample_waveform.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ddc__waveform_8c.html">ddc_waveform.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="downmix__waveform_8c.html">downmix_waveform.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fft__waveform_8c.html">fft_waveform.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fit__diodepulse_8c.html">fit_diodepulse.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fit__fft_8c.html">fit_fft.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fit__waveform_8c.html">fit_waveform.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="get__IQ_8c.html">get_IQ.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="get__pedestal_8c.html">get_pedestal.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="get__pos_8c.html">get_pos.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="get__slope_8c.html">get_slope.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="get__t0_8c.html">get_t0.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="postprocess__waveform_8c.html">postprocess_waveform.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__caltone_8c.html">process_caltone.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__diode_8c.html">process_diode.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__dipole_8c.html">process_dipole.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__monopole_8c.html">process_monopole.c</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__waveform_8c.html">process_waveform.c</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g42cc22e8c958743e2bd86fe5bdfdd42d">PROC_DEFAULT</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7753a1dae883290ad0e5ba65147e9f13"></a><!-- doxytag: member="processing::PROC_DO_FFT" ref="g7753a1dae883290ad0e5ba65147e9f13" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DO_FFT</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf546dfa71990db7bf7eeec36d8d60a59"></a><!-- doxytag: member="processing::PROC_DO_FIT" ref="gf546dfa71990db7bf7eeec36d8d60a59" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DO_FIT</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6c2a8696b49c25e4f29252c3a6d6ac3a"></a><!-- doxytag: member="processing::PROC_DO_DDC" ref="g6c2a8696b49c25e4f29252c3a6d6ac3a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DO_DDC</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g21955fd76a7620b71f44fdd66356e04b"></a><!-- doxytag: member="processing::PROC_DDC_CALIBFREQ" ref="g21955fd76a7620b71f44fdd66356e04b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DDC_CALIBFREQ</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gca7f027c67eaec7448bb5df686b7b0d4"></a><!-- doxytag: member="processing::PROC_DDC_CALIBTDECAY" ref="gca7f027c67eaec7448bb5df686b7b0d4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DDC_CALIBTDECAY</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5730568b109a13eb72680a14857dbbb9"></a><!-- doxytag: member="processing::PROC_DDC_FITFREQ" ref="g5730568b109a13eb72680a14857dbbb9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DDC_FITFREQ</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga79556cfe04c3b7c9c039fa1f277c901"></a><!-- doxytag: member="processing::PROC_DDC_FITTDECAY" ref="ga79556cfe04c3b7c9c039fa1f277c901" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DDC_FITTDECAY</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9eb43ef7c8ecd8d8f728efde9ba522a2"></a><!-- doxytag: member="processing::PROC_DDC_FFTFREQ" ref="g9eb43ef7c8ecd8d8f728efde9ba522a2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DDC_FFTFREQ</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g516ea3a0590d5902fe107655b03db0c8"></a><!-- doxytag: member="processing::PROC_DDC_FFTTDECAY" ref="g516ea3a0590d5902fe107655b03db0c8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DDC_FFTTDECAY</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1bfa87418a15d7f7e87d6b479c1dcb55"></a><!-- doxytag: member="processing::PROC_DDC_FULL" ref="g1bfa87418a15d7f7e87d6b479c1dcb55" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_DDC_FULL</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga2774a6d8a9ea83cc4121e385f8e20ec"></a><!-- doxytag: member="processing::PROC_FIT_DDC" ref="ga2774a6d8a9ea83cc4121e385f8e20ec" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_FIT_DDC</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbe1a2c0c3d7c8f256d3f3b2df2ade610"></a><!-- doxytag: member="processing::PROC_FIT_FFT" ref="gbe1a2c0c3d7c8f256d3f3b2df2ade610" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_FIT_FFT</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1b4ba11635f5e3ec0ae70b6eaa858725"></a><!-- doxytag: member="processing::PROC_RAW_PHASE" ref="g1b4ba11635f5e3ec0ae70b6eaa858725" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_RAW_PHASE</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd634d8b142407b14b2ed1784764025c0"></a><!-- doxytag: member="processing::PROC_CORR_AMP" ref="gd634d8b142407b14b2ed1784764025c0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_CORR_AMP</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd99c4784aba9a6afaa18896c5736d60c"></a><!-- doxytag: member="processing::PROC_CORR_PHASE" ref="gd99c4784aba9a6afaa18896c5736d60c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_CORR_PHASE</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g40fc552f6d97737b3521d75173f86597"></a><!-- doxytag: member="processing::PROC_CORR_GAIN" ref="g40fc552f6d97737b3521d75173f86597" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROC_CORR_GAIN</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g64dcc54dd58051ed9183a44b791ed73b">process_diode</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="el" href="structbpmconf.html">bpmconf_t</a> *conf, <a class="el" href="structbpmproc.html">bpmproc_t</a> *proc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g4d159862631514e412a0f30e278e9426">process_monopole</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="el" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="el" href="structbpmcalib.html">bpmcalib_t</a> *cal, <a class="el" href="structbpmproc.html">bpmproc_t</a> *proc, <a class="el" href="structbpmproc.html">bpmproc_t</a> *trig, unsigned int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g7263f2231c573bf98d41dbaab82c01be">process_dipole</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="el" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="el" href="structbpmcalib.html">bpmcalib_t</a> *cal, <a class="el" href="structbpmproc.html">bpmproc_t</a> *proc, <a class="el" href="structbpmproc.html">bpmproc_t</a> *trig, <a class="el" href="structbpmproc.html">bpmproc_t</a> *ampref, <a class="el" href="structbpmproc.html">bpmproc_t</a> *phaseref, unsigned int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gbd8d3c45cc42c393a13e1471b1dac2c2">process_waveform</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="el" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="el" href="structbpmproc.html">bpmproc_t</a> *proc, <a class="el" href="structbpmproc.html">bpmproc_t</a> *trig, unsigned int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g12b153af4b09cd59e863cef0bf5114c3">postprocess_waveform</a> (<a class="el" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="el" href="structbpmproc.html">bpmproc_t</a> *proc, <a class="el" href="structbpmcalib.html">bpmcalib_t</a> *cal, <a class="el" href="structbpmproc.html">bpmproc_t</a> *ampref, <a class="el" href="structbpmproc.html">bpmproc_t</a> *phaseref, unsigned int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g25fcb848f5ef6ad50b2d0ab683b9ff00">process_caltone</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *signal, <a class="el" href="structbpmconf.html">bpmconf_t</a> *bpm, <a class="el" href="structbpmproc.html">bpmproc_t</a> *proc, unsigned int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gfbefcc42457d943c215b3a423540a145">correct_gain</a> (<a class="el" href="structbpmproc.html">bpmproc_t</a> *proc, <a class="el" href="structbpmcalib.html">bpmcalib_t</a> *cal, unsigned int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gef5c2fd31031b3a529366aef80699d23">fit_waveform</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, double t0, double i_freq, double i_tdecay, double i_amp, double i_phase, double *freq, double *tdecay, double *amp, double *phase)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g8435d116a246f99a782b4fd516990248">fit_diodepulse</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, double *t0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g702adf29e485a816b5b8b2dbefb6fe6a">fft_waveform</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, <a class="el" href="structcomplexwf__t.html">complexwf_t</a> *ft)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g91374c399c6b149ac8ca96ee1245dc7a">fit_fft_prepare</a> (<a class="el" href="structcomplexwf__t.html">complexwf_t</a> *ft, int *n1, int *n2, double *amp, double *freq, double *fwhm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gabfbe75e2891a3756443d476b05c9b61">fit_fft</a> (<a class="el" href="structcomplexwf__t.html">complexwf_t</a> *ft, double *freq, double *tdecay, double *A, double *C)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gb0f5fd9a629e07038d336c0aad2cf41c">check_saturation</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, int nbits, int *iunsat)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g9153adcd6718410b99010b3ad3209edb">downmix_waveform</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, double frequency, <a class="el" href="structcomplexwf__t.html">complexwf_t</a> *out)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g4d5ba258550486446e98b18b06d793f9">ddc_waveform</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, double frequency, <a class="el" href="structfilter__t.html">filter_t</a> *filt, <a class="el" href="structcomplexwf__t.html">complexwf_t</a> *dc, <a class="el" href="structdoublewf__t.html">doublewf_t</a> *buf_re, <a class="el" href="structdoublewf__t.html">doublewf_t</a> *buf_im)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gddd40cf316f88ea006e2e68424cb6987">ddc_sample_waveform</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, double frequency, <a class="el" href="structfilter__t.html">filter_t</a> *filt, int iSample, double t0, double tdecay, double *amp, double *phase, <a class="el" href="structdoublewf__t.html">doublewf_t</a> *buf_re, <a class="el" href="structdoublewf__t.html">doublewf_t</a> *buf_im)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gbbcbc20893990f64b46cfde9c823c4aa">get_pedestal</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *wf, int range, double *offset, double *rms)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gac8e6d526cd906365ad1fa23f07b865d">get_t0</a> (<a class="el" href="structdoublewf__t.html">doublewf_t</a> *w, double *t0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#gd7417582fb39b8f0cd38a4e28618bf2b">get_IQ</a> (double amp, double phase, double refamp, double refphase, double *Q, double *I)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g6906c83d2017b8c2536b31881155e8a6">get_pos</a> (double Q, double I, double IQphase, double posscale, double *pos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__processing.html#g4010b123b9d6424c97ea9ea77b7a8e4d">get_slope</a> (double Q, double I, double IQphase, double slopescale, double *slope)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g42cc22e8c958743e2bd86fe5bdfdd42d"></a><!-- doxytag: member="bpm_process.h::PROC_DEFAULT" ref="g42cc22e8c958743e2bd86fe5bdfdd42d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROC_DEFAULT          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="bpm__process_8h-source.html#l00331">331</a> of file <a class="el" href="bpm__process_8h-source.html">bpm_process.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g64dcc54dd58051ed9183a44b791ed73b"></a><!-- doxytag: member="bpm_process.h::process_diode" ref="g64dcc54dd58051ed9183a44b791ed73b" args="(doublewf_t *signal, bpmconf_t *conf, bpmproc_t *proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int process_diode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmconf.html">bpmconf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine processes a diode pulse, which should be found in the signal structure. It fills the proc structure with the t0. The routine checks what the signal type (conf-&gt;cav_type) is and when it really is a diode pulse, it will fit the pulse and return t0, otherwise (when the signal is a monopole or dipole signal), it will determine the onset of the waveform by looking where the signal's absolute value exceeds 10 * the noise RMS at the beginning of the waveform.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>The bpm signal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>The bpm configuration structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The processed trigger structure (containing the t0)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="process__diode_8c-source.html#l00009">9</a> of file <a class="el" href="process__diode_8c-source.html">process_diode.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__interface_8h-source.html#l00089">bpmconf::cav_type</a>, <a class="el" href="bpm__interface_8h-source.html#l00042">diode</a>, <a class="el" href="doublewf_8c-source.html#l00467">doublewf_basic_stats()</a>, <a class="el" href="fit__diodepulse_8c-source.html#l00010">fit_diodepulse()</a>, <a class="el" href="bpm__interface_8h-source.html#l00142">bpmconf::forced_trigger</a>, <a class="el" href="bpm__wf_8h-source.html#l00176">doublewf_t::fs</a>, <a class="el" href="bpm__wf_8h-source.html#l00201">wfstat_t::mean</a>, <a class="el" href="bpm__interface_8h-source.html#l00087">bpmconf::name</a>, <a class="el" href="bpm__wf_8h-source.html#l00175">doublewf_t::ns</a>, <a class="el" href="bpm__wf_8h-source.html#l00202">wfstat_t::rms</a>, <a class="el" href="bpm__interface_8h-source.html#l00175">bpmproc::t0</a>, and <a class="el" href="bpm__wf_8h-source.html#l00177">doublewf_t::wf</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4d159862631514e412a0f30e278e9426"></a><!-- doxytag: member="bpm_process.h::process_monopole" ref="g4d159862631514e412a0f30e278e9426" args="(doublewf_t *signal, bpmconf_t *bpm, bpmcalib_t *cal, bpmproc_t *proc, bpmproc_t *trig, unsigned int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int process_monopole           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmconf.html">bpmconf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>bpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmcalib.html">bpmcalib_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>trig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top-level routine which is basically a wrapper around process_waveform and correct_gain to take into account the calibration tone data. See more in details documentation in those routines.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>The <a class="el" href="structdoublewf__t.html">doublewf_t</a> encoded BPM signal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpm</em>&nbsp;</td><td>The bpm configuration structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cal</em>&nbsp;</td><td>The bpm calibration structure, needed for the gain correction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The processed data structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trig</em>&nbsp;</td><td>The structure with processed trigger info for that waveform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A bitpattern encoding what exactly to process</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="process__monopole_8c-source.html#l00011">11</a> of file <a class="el" href="process__monopole_8c-source.html">process_monopole.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="correct__gain_8c-source.html#l00010">correct_gain()</a>, <a class="el" href="bpm__interface_8h-source.html#l00087">bpmconf::name</a>, and <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7263f2231c573bf98d41dbaab82c01be"></a><!-- doxytag: member="bpm_process.h::process_dipole" ref="g7263f2231c573bf98d41dbaab82c01be" args="(doublewf_t *signal, bpmconf_t *bpm, bpmcalib_t *cal, bpmproc_t *proc, bpmproc_t *trig, bpmproc_t *ampref, bpmproc_t *phaseref, unsigned int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int process_dipole           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmconf.html">bpmconf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>bpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmcalib.html">bpmcalib_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>trig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ampref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>phaseref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top-level routine which is a wrapper around process_waveform, correct_gain and postprocess_waveform. See more details in the documentation of those individual routines.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>The <a class="el" href="structdoublewf__t.html">doublewf_t</a> encoded BPM signal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpm</em>&nbsp;</td><td>The bpm configuration structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cal</em>&nbsp;</td><td>The bpm calibration structure, needed for the gain correction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The processed data structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trig</em>&nbsp;</td><td>The structure with processed trigger info for that waveform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ampref</em>&nbsp;</td><td>The already processed amplitude reference bpmproc_t structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseref</em>&nbsp;</td><td>The already processed phase reference bpmproc_t structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A bitpattern encoding what exactly to process</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="process__dipole_8c-source.html#l00010">10</a> of file <a class="el" href="process__dipole_8c-source.html">process_dipole.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="correct__gain_8c-source.html#l00010">correct_gain()</a>, <a class="el" href="bpm__interface_8h-source.html#l00087">bpmconf::name</a>, <a class="el" href="postprocess__waveform_8c-source.html#l00010">postprocess_waveform()</a>, and <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gbd8d3c45cc42c393a13e1471b1dac2c2"></a><!-- doxytag: member="bpm_process.h::process_waveform" ref="gbd8d3c45cc42c393a13e1471b1dac2c2" args="(doublewf_t *signal, bpmconf_t *bpm, bpmproc_t *proc, bpmproc_t *trig, unsigned int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int process_waveform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmconf.html">bpmconf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>bpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>trig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top-level routine to processes a BPM beam pulse waveform (decaying "sin"-like wave) and derive amplitude and phase from the signal. The routine needs to be fed with a <a class="el" href="structdoublewf__t.html">doublewf_t</a> containing the digitized signal. The signal is checked for saturation, it's pedestal is determined and removed, the pulse starttime (t0) is set from the configuration or the trigger. Then, depending on the mode bitpattern, an FFT is performed, the waveform is fitted and a digital downconversion is done. The results (amplitude and phase) are stored in the bpmproc_t structure of the BPM.<p>
Relevant mode bit patterns for this routine are :<ul>
<li>PROC_DO_FFT : The Fourier Transform of the waveform gets computed and stored as a <a class="el" href="structcomplexwf__t.html">complexwf_t</a> in the <a class="el" href="structbpmproc.html#c6f3c265a080e664e10cc6f2339662a7">bpmproc_t::ft</a> variable.</li><li>PROC_FIT_FFT : An attempt to fit the Fourier Transform is made using a Lorentizan Lineshape. If successfull, the <a class="el" href="structbpmproc.html#17d339f93b81bc99d632b9c5ffc8da85">bpmproc_t::fft_freq</a> and <a class="el" href="structbpmproc.html#ff324567b6af56170b2efe3f658eeac4">bpmproc_t::fft_tdecay</a> variables will contain the fitted frequency and decaytime. I recommend however to use a 3th party fitting routine for this (e.g. MINUIT) and implement this in a user program.</li><li>PROC_DO_FIT : Attempts to fit a decaying sine wave to the waveform having the frequency, the decay time, the amplitude and phase as free parameters. If successfull, the <a class="el" href="structbpmproc.html#95c3ffbd8041ee333f7fb197b80d79b3">bpmproc_t::fit_freq</a>, <a class="el" href="structbpmproc.html#ad6477fbcd2c2ead538bef6e17c27022">bpmproc_t::fit_amp</a>, <a class="el" href="structbpmproc.html#eb36a2ab357ca13c3c8352feb8cb6e8d">bpmproc_t::fit_phase</a> and <a class="el" href="structbpmproc.html#7f14eec6bdb4338ddc1f25b7f83d6c27">bpmproc_t::fit_tdecay</a> will contain the fit parameters. Again, I recommend to use a 3th party fitting routine for this.</li><li>PROC_DO_DDC : Will perform a digital downconversion on the waveform. The results are contained in <a class="el" href="structbpmproc.html#f2defdec0144996a00deab9a30461241">bpmproc_t::ddc_amp</a> and <a class="el" href="structbpmproc.html#f2a86e422e93b453b91206abccc0b351">bpmproc_t::ddc_phase</a>, determined at <a class="el" href="structbpmproc.html#53c95ca0b2fa62c817fa4a14052f2a92">bpmproc_t::ddc_tSample</a>, but extrapolated back to <a class="el" href="structbpmproc.html#882cae0e540fd6d8557628a7edcb449d">bpmproc_t::t0</a>.</li><li>PROC_DDC_FITTDECAY, PROC_DDC_FFTTDECAY : Normally the ddc algoritm gets it's decay time for extrapolation back to t0 from the <a class="el" href="structbpmconf.html#626f42b1ed03ecc448dbf6a64852f793">bpmconf_t::ddc_tdecay</a> variable, if one of these flags are set it will get them from the fitted waveform or FFT if they were succesful.</li><li>PROC_DDC_FITFREQ, PROC_DDC_FFTFREQ : Analogous as the previous item, but now for the ddc frequency which is normally obtained from <a class="el" href="structbpmconf.html#6c054672fa971d58fd3c50040d9a7e57">bpmconf_t::ddc_freq</a>.</li><li>PROC_DDC_FULL : Will perform the DDC algorithm on the entire waveform and store the result in <a class="el" href="structbpmproc.html#64c8db22258e28f24d7db38244b5df98">bpmproc_t::dc</a></li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>The digitized signal converted into a <a class="el" href="structdoublewf__t.html">doublewf_t</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpm</em>&nbsp;</td><td>A pointer to the bpmconf_t structure for the BPM channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>A pointer to the bpmproc_t structure for the BPM channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trig</em>&nbsp;</td><td>A pointer to the bpmproc_t structure of the trigger for this BPM channel, if this parameter is NULL, externall clocking will be assumed and the t0 from the bpmconf_t structure will be used in the processing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The processing mode bitword </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon succes, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="process__waveform_8c-source.html#l00012">12</a> of file <a class="el" href="process__waveform_8c-source.html">process_waveform.c</a>.</p>

<p>References <a class="el" href="bpm__interface_8h-source.html#l00172">bpmproc::ampnoise</a>, <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__warning_8c-source.html#l00009">bpm_warning()</a>, <a class="el" href="bpm__interface_8h-source.html#l00096">bpmconf::cav_decaytime</a>, <a class="el" href="check__saturation_8c-source.html#l00011">check_saturation()</a>, <a class="el" href="bpm__interface_8h-source.html#l00180">bpmproc::dc</a>, <a class="el" href="bpm__interface_8h-source.html#l00196">bpmproc::ddc_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00146">bpmconf::ddc_buffer_im</a>, <a class="el" href="bpm__interface_8h-source.html#l00145">bpmconf::ddc_buffer_re</a>, <a class="el" href="bpm__interface_8h-source.html#l00122">bpmconf::ddc_filter</a>, <a class="el" href="bpm__interface_8h-source.html#l00119">bpmconf::ddc_freq</a>, <a class="el" href="bpm__interface_8h-source.html#l00193">bpmproc::ddc_iSample</a>, <a class="el" href="bpm__interface_8h-source.html#l00197">bpmproc::ddc_phase</a>, <a class="el" href="ddc__sample__waveform_8c-source.html#l00019">ddc_sample_waveform()</a>, <a class="el" href="bpm__interface_8h-source.html#l00191">bpmproc::ddc_success</a>, <a class="el" href="bpm__interface_8h-source.html#l00120">bpmconf::ddc_tdecay</a>, <a class="el" href="bpm__interface_8h-source.html#l00121">bpmconf::ddc_tOffset</a>, <a class="el" href="bpm__interface_8h-source.html#l00192">bpmproc::ddc_tSample</a>, <a class="el" href="ddc__waveform_8c-source.html#l00012">ddc_waveform()</a>, <a class="el" href="bpm__interface_8h-source.html#l00107">bpmconf::digi_freq</a>, <a class="el" href="bpm__interface_8h-source.html#l00108">bpmconf::digi_nbits</a>, <a class="el" href="bpm__interface_8h-source.html#l00109">bpmconf::digi_nsamples</a>, <a class="el" href="doublewf_8c-source.html#l00385">doublewf_bias()</a>, <a class="el" href="bpm__interface_8h-source.html#l00186">bpmproc::fft_freq</a>, <a class="el" href="bpm__interface_8h-source.html#l00184">bpmproc::fft_success</a>, <a class="el" href="bpm__interface_8h-source.html#l00187">bpmproc::fft_tdecay</a>, <a class="el" href="fft__waveform_8c-source.html#l00012">fft_waveform()</a>, <a class="el" href="bpm__interface_8h-source.html#l00210">bpmproc::fit_amp</a>, <a class="el" href="fit__fft_8c-source.html#l00148">fit_fft()</a>, <a class="el" href="bpm__interface_8h-source.html#l00212">bpmproc::fit_freq</a>, <a class="el" href="bpm__interface_8h-source.html#l00211">bpmproc::fit_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00207">bpmproc::fit_success</a>, <a class="el" href="bpm__interface_8h-source.html#l00213">bpmproc::fit_tdecay</a>, <a class="el" href="bpm__interface_8h-source.html#l00127">bpmconf::fit_tOffset</a>, <a class="el" href="fit__waveform_8c-source.html#l00080">fit_waveform()</a>, <a class="el" href="bpm__interface_8h-source.html#l00181">bpmproc::ft</a>, <a class="el" href="get__pedestal_8c-source.html#l00010">get_pedestal()</a>, <a class="el" href="bpm__interface_8h-source.html#l00178">bpmproc::iunsat</a>, <a class="el" href="bpm__interface_8h-source.html#l00087">bpmconf::name</a>, <a class="el" href="norm__phase_8c-source.html#l00008">norm_phase()</a>, <a class="el" href="bpm__interface_8h-source.html#l00177">bpmproc::saturated</a>, <a class="el" href="bpm__interface_8h-source.html#l00116">bpmconf::t0</a>, <a class="el" href="bpm__interface_8h-source.html#l00175">bpmproc::t0</a>, <a class="el" href="bpm__interface_8h-source.html#l00173">bpmproc::voltageoffset</a>, and <a class="el" href="bpm__wf_8h-source.html#l00191">complexwf_t::wf</a>.</p>

<p>Referenced by <a class="el" href="process__dipole_8c-source.html#l00010">process_dipole()</a>, and <a class="el" href="process__monopole_8c-source.html#l00011">process_monopole()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g12b153af4b09cd59e863cef0bf5114c3"></a><!-- doxytag: member="bpm_process.h::postprocess_waveform" ref="g12b153af4b09cd59e863cef0bf5114c3" args="(bpmconf_t *bpm, bpmproc_t *proc, bpmcalib_t *cal, bpmproc_t *ampref, bpmproc_t *phaseref, unsigned int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int postprocess_waveform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbpmconf.html">bpmconf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>bpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmcalib.html">bpmcalib_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ampref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>phaseref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top-level routine to Post-process a waveform for whith the amplitude and the phase have already been defined using process_waveform. This routine goes on to calculate I and Q from the phase and amplitudes as well as the postion and slope using the calibration information.<p>
Relevant mode bit patterns for this routine are :<ul>
<li>PROC_RAW_PHASE : when this bit is active in the mode word, the routine will not replace the phase in the bpmproc_t structure by the phase difference between the reference cavity and the processed cavity. Under normal circumstances you don't want this since it's only the phase difference which actually has any physical meaning.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>The digitized signal converted into a <a class="el" href="structdoublewf__t.html">doublewf_t</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpm</em>&nbsp;</td><td>A pointer to the bpmconf_t structure for the BPM channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>A pointer to the bpmproc_t structure for the BPM channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cal</em>&nbsp;</td><td>A pointer to the bpmcalib_t structure for the BPM channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ampref</em>&nbsp;</td><td>A pointer to the bpmproc_t structure of the amplitude reference channel for this BPM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseref</em>&nbsp;</td><td>A pointer to the bpmproc_t structure of the phase reference channel for this BPM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The processing mode bitword </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon succes, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="postprocess__waveform_8c-source.html#l00010">10</a> of file <a class="el" href="postprocess__waveform_8c-source.html">postprocess_waveform.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__interface_8h-source.html#l00196">bpmproc::ddc_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00195">bpmproc::ddc_I</a>, <a class="el" href="bpm__interface_8h-source.html#l00154">bpmcalib::ddc_IQphase</a>, <a class="el" href="bpm__interface_8h-source.html#l00197">bpmproc::ddc_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00200">bpmproc::ddc_pos</a>, <a class="el" href="bpm__interface_8h-source.html#l00155">bpmcalib::ddc_posscale</a>, <a class="el" href="bpm__interface_8h-source.html#l00194">bpmproc::ddc_Q</a>, <a class="el" href="bpm__interface_8h-source.html#l00201">bpmproc::ddc_slope</a>, <a class="el" href="bpm__interface_8h-source.html#l00156">bpmcalib::ddc_slopescale</a>, <a class="el" href="bpm__interface_8h-source.html#l00191">bpmproc::ddc_success</a>, <a class="el" href="bpm__interface_8h-source.html#l00210">bpmproc::fit_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00209">bpmproc::fit_I</a>, <a class="el" href="bpm__interface_8h-source.html#l00161">bpmcalib::fit_IQphase</a>, <a class="el" href="bpm__interface_8h-source.html#l00211">bpmproc::fit_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00216">bpmproc::fit_pos</a>, <a class="el" href="bpm__interface_8h-source.html#l00162">bpmcalib::fit_posscale</a>, <a class="el" href="bpm__interface_8h-source.html#l00208">bpmproc::fit_Q</a>, <a class="el" href="bpm__interface_8h-source.html#l00217">bpmproc::fit_slope</a>, <a class="el" href="bpm__interface_8h-source.html#l00163">bpmcalib::fit_slopescale</a>, <a class="el" href="bpm__interface_8h-source.html#l00207">bpmproc::fit_success</a>, <a class="el" href="get__IQ_8c-source.html#l00008">get_IQ()</a>, <a class="el" href="get__pos_8c-source.html#l00008">get_pos()</a>, <a class="el" href="get__slope_8c-source.html#l00008">get_slope()</a>, <a class="el" href="bpm__interface_8h-source.html#l00087">bpmconf::name</a>, and <a class="el" href="norm__phase_8c-source.html#l00008">norm_phase()</a>.</p>

<p>Referenced by <a class="el" href="process__dipole_8c-source.html#l00010">process_dipole()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g25fcb848f5ef6ad50b2d0ab683b9ff00"></a><!-- doxytag: member="bpm_process.h::process_caltone" ref="g25fcb848f5ef6ad50b2d0ab683b9ff00" args="(doublewf_t *signal, bpmconf_t *bpm, bpmproc_t *proc, unsigned int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int process_caltone           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmconf.html">bpmconf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>bpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top level routine to process the calibration tone via DDC, similar to process_waveform but it also updates the ddc_ct_amp and ddc_ct_phase variables in the bpmproc_t structure. No fitting is implemented in this routine.<p>
Relevant mode bit patterns for this routine are analogous as in process_waveform<ul>
<li>PROC_DO_FFT : see process_waveform</li><li>PROC_FIT_FFT : see process_waveform</li><li>PROC_DO_DDC : see process_waveform</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>The digitized signal converted into a <a class="el" href="structdoublewf__t.html">doublewf_t</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpm</em>&nbsp;</td><td>A pointer to the bpmconf_t structure for the BPM channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>A pointer to the bpmproc_t structure for the BPM channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The processing mode bitword</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon succes, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="process__caltone_8c-source.html#l00011">11</a> of file <a class="el" href="process__caltone_8c-source.html">process_caltone.c</a>.</p>

<p>References <a class="el" href="bpm__interface_8h-source.html#l00172">bpmproc::ampnoise</a>, <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__warning_8c-source.html#l00009">bpm_warning()</a>, <a class="el" href="check__saturation_8c-source.html#l00011">check_saturation()</a>, <a class="el" href="bpm__interface_8h-source.html#l00180">bpmproc::dc</a>, <a class="el" href="bpm__interface_8h-source.html#l00196">bpmproc::ddc_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00146">bpmconf::ddc_buffer_im</a>, <a class="el" href="bpm__interface_8h-source.html#l00145">bpmconf::ddc_buffer_re</a>, <a class="el" href="bpm__interface_8h-source.html#l00203">bpmproc::ddc_ct_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00131">bpmconf::ddc_ct_filter</a>, <a class="el" href="bpm__interface_8h-source.html#l00130">bpmconf::ddc_ct_freq</a>, <a class="el" href="bpm__interface_8h-source.html#l00132">bpmconf::ddc_ct_iSample</a>, <a class="el" href="bpm__interface_8h-source.html#l00204">bpmproc::ddc_ct_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00197">bpmproc::ddc_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00191">bpmproc::ddc_success</a>, <a class="el" href="ddc__waveform_8c-source.html#l00012">ddc_waveform()</a>, <a class="el" href="bpm__interface_8h-source.html#l00108">bpmconf::digi_nbits</a>, <a class="el" href="doublewf_8c-source.html#l00385">doublewf_bias()</a>, <a class="el" href="bpm__interface_8h-source.html#l00186">bpmproc::fft_freq</a>, <a class="el" href="bpm__interface_8h-source.html#l00184">bpmproc::fft_success</a>, <a class="el" href="bpm__interface_8h-source.html#l00187">bpmproc::fft_tdecay</a>, <a class="el" href="fft__waveform_8c-source.html#l00012">fft_waveform()</a>, <a class="el" href="fit__fft_8c-source.html#l00148">fit_fft()</a>, <a class="el" href="bpm__interface_8h-source.html#l00181">bpmproc::ft</a>, <a class="el" href="get__pedestal_8c-source.html#l00010">get_pedestal()</a>, <a class="el" href="bpm__interface_8h-source.html#l00178">bpmproc::iunsat</a>, <a class="el" href="bpm__interface_8h-source.html#l00087">bpmconf::name</a>, <a class="el" href="norm__phase_8c-source.html#l00008">norm_phase()</a>, <a class="el" href="bpm__interface_8h-source.html#l00177">bpmproc::saturated</a>, <a class="el" href="bpm__interface_8h-source.html#l00173">bpmproc::voltageoffset</a>, and <a class="el" href="bpm__wf_8h-source.html#l00191">complexwf_t::wf</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfbefcc42457d943c215b3a423540a145"></a><!-- doxytag: member="bpm_process.h::correct_gain" ref="gfbefcc42457d943c215b3a423540a145" args="(bpmproc_t *proc, bpmcalib_t *cal, unsigned int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int correct_gain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbpmproc.html">bpmproc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbpmcalib.html">bpmcalib_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Correct the processed amplitude and phase by using calibration tone information if the ddc and or fits were successfull. Since e.g. for internal clock it is not really sure the phase information can be used if there is no proper trigger, some mode bits can be flagged to only correct the amplitude.<p>
Relevant mode bit patterns for this routine are :<ul>
<li>PROC_CORR_AMP : Correct the amplitude</li><li>PROC_CORR_PHASE : Correct the phase</li><li>PROC_CORR_GAIN : Correct both of them</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The bpmproc_t structure of the bpm </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cal</em>&nbsp;</td><td>The bpmcalib_t structure of the bpm </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Mode of correction</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="correct__gain_8c-source.html#l00010">10</a> of file <a class="el" href="correct__gain_8c-source.html">correct_gain.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__interface_8h-source.html#l00196">bpmproc::ddc_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00157">bpmcalib::ddc_ct_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00203">bpmproc::ddc_ct_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00158">bpmcalib::ddc_ct_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00204">bpmproc::ddc_ct_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00197">bpmproc::ddc_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00191">bpmproc::ddc_success</a>, <a class="el" href="bpm__interface_8h-source.html#l00210">bpmproc::fit_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00164">bpmcalib::fit_ct_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00219">bpmproc::fit_ct_amp</a>, <a class="el" href="bpm__interface_8h-source.html#l00165">bpmcalib::fit_ct_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00220">bpmproc::fit_ct_phase</a>, <a class="el" href="bpm__interface_8h-source.html#l00211">bpmproc::fit_phase</a>, and <a class="el" href="bpm__interface_8h-source.html#l00207">bpmproc::fit_success</a>.</p>

<p>Referenced by <a class="el" href="process__dipole_8c-source.html#l00010">process_dipole()</a>, and <a class="el" href="process__monopole_8c-source.html#l00011">process_monopole()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gef5c2fd31031b3a529366aef80699d23"></a><!-- doxytag: member="bpm_process.h::fit_waveform" ref="gef5c2fd31031b3a529366aef80699d23" args="(doublewf_t *w, double t0, double i_freq, double i_tdecay, double i_amp, double i_phase, double *freq, double *tdecay, double *amp, double *phase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int fit_waveform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>i_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>i_tdecay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>i_amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>i_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>tdecay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fits the waveform with a decaying sin wave using the lmder/lmdif routines from <a class="el" href="nr__levmar_8c.html">nr_levmar.c</a> !<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Note that this routine is highly experimental, so don't use it for real production stuff. Instead I recommend using a proper minimisation package like MINUIT or so...</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*w</em>&nbsp;</td><td>The waveform encoded as a <a class="el" href="structdoublewf__t.html">doublewf_t</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>t0 for the waveform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_freq</em>&nbsp;</td><td>Initial frequency for the fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_tdecay</em>&nbsp;</td><td>Initial decay time for the fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_amp</em>&nbsp;</td><td>Initial amplitude for the fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_phase</em>&nbsp;</td><td>Initial phase for the fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq</em>&nbsp;</td><td>Fitted frequency </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tdecay</em>&nbsp;</td><td>Fitted decay time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amp</em>&nbsp;</td><td>Fitted amplitude </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phase</em>&nbsp;</td><td>Fitted phase</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="fit__waveform_8c-source.html#l00080">80</a> of file <a class="el" href="fit__waveform_8c-source.html">fit_waveform.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="doublewf_8c-source.html#l00008">doublewf()</a>, <a class="el" href="doublewf_8c-source.html#l00202">doublewf_delete()</a>, <a class="el" href="bpm__wf_8h-source.html#l00176">doublewf_t::fs</a>, <a class="el" href="bpm__wf_8h-source.html#l00175">doublewf_t::ns</a>, and <a class="el" href="bpm__wf_8h-source.html#l00177">doublewf_t::wf</a>.</p>

<p>Referenced by <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8435d116a246f99a782b4fd516990248"></a><!-- doxytag: member="bpm_process.h::fit_diodepulse" ref="g8435d116a246f99a782b4fd516990248" args="(doublewf_t *w, double *t0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int fit_diodepulse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>t0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fits the diode pulse, basically a wrapper for get_t0, to conserve names and consistency in the library... is nothing more than a wrapper around get_t0, so see there... 
<p>Definition at line <a class="el" href="fit__diodepulse_8c-source.html#l00010">10</a> of file <a class="el" href="fit__diodepulse_8c-source.html">fit_diodepulse.c</a>.</p>

<p>References <a class="el" href="get__t0_8c-source.html#l00046">get_t0()</a>.</p>

<p>Referenced by <a class="el" href="process__diode_8c-source.html#l00009">process_diode()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g702adf29e485a816b5b8b2dbefb6fe6a"></a><!-- doxytag: member="bpm_process.h::fft_waveform" ref="g702adf29e485a816b5b8b2dbefb6fe6a" args="(doublewf_t *w, complexwf_t *ft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int fft_waveform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexwf__t.html">complexwf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ft</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a fast fourier transform of the waveform, after subtracting the pedestal, basically just a wrapper around the forward realfft routine from the DSP module. Please see it's documentation for more details...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*w</em>&nbsp;</td><td>the waveform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fft</em>&nbsp;</td><td>the complex returned fft spectrum</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="fft__waveform_8c-source.html#l00012">12</a> of file <a class="el" href="fft__waveform_8c-source.html">fft_waveform.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__dsp_8h-source.html#l00414">FFT_FORWARD</a>, and <a class="el" href="discrete__fourier__transforms_8c-source.html#l00230">realfft()</a>.</p>

<p>Referenced by <a class="el" href="process__caltone_8c-source.html#l00011">process_caltone()</a>, and <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g91374c399c6b149ac8ca96ee1245dc7a"></a><!-- doxytag: member="bpm_process.h::fit_fft_prepare" ref="g91374c399c6b149ac8ca96ee1245dc7a" args="(complexwf_t *ft, int *n1, int *n2, double *amp, double *freq, double *fwhm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int fit_fft_prepare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexwf__t.html">complexwf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fwhm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine prepares the fft fit of the waveform. It starts by getting the position of the maximum in the spectrum (first nyquist band only). Then from this position runs left and right to determine where the amplitude drops to half of the peak amplitude and have an initial estimation of the FWHM. It will then set twice the FWHM width as the fit range in which to perform the fit, this is than returned by the samplnumbers n1 and n2.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ft</em>&nbsp;</td><td>The <a class="el" href="structcomplexwf__t.html">complexwf_t</a> fourier transform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n1</em>&nbsp;</td><td>The first sample to start the fit from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n2</em>&nbsp;</td><td>The last sample to take into account in the following fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amp</em>&nbsp;</td><td>Initial estimation of the amplitude for the fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq</em>&nbsp;</td><td>Initial estimation of the frequency for the fit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fwhm</em>&nbsp;</td><td>Initial estimation of the FWHM for the fit.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure. </dd></dl>

<p>Definition at line <a class="el" href="fit__fft_8c-source.html#l00072">72</a> of file <a class="el" href="fit__fft_8c-source.html">fit_fft.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__wf_8h-source.html#l00190">complexwf_t::fs</a>, <a class="el" href="bpm__wf_8h-source.html#l00189">complexwf_t::ns</a>, and <a class="el" href="bpm__wf_8h-source.html#l00191">complexwf_t::wf</a>.</p>

<p>Referenced by <a class="el" href="fit__fft_8c-source.html#l00148">fit_fft()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gabfbe75e2891a3756443d476b05c9b61"></a><!-- doxytag: member="bpm_process.h::fit_fft" ref="gabfbe75e2891a3756443d476b05c9b61" args="(complexwf_t *ft, double *freq, double *tdecay, double *A, double *C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int fit_fft           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexwf__t.html">complexwf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>tdecay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fits the power spectrum of the FT of a waveform frequency and decay time. Internally it makes a call to fit_fft_prepare to get an initial estimation of the parameters and goes on by applying the nr_lmder routine to minimise the fourier transform power spectrum agains a lorentzian lineshape defined by<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ L = \frac{p_0}{ ( f - p_1 )^2 + \left( \frac{p_2}{2} \right)^2 } + p_3 \]" src="form_5.png">
<p>
<p>
Where<ul>
<li>p0 = the amplitude of the power spectrum</li><li>p1 = the frequency of the fourier transform peak</li><li>p2 = the full width at half maximum</li><li>p3 = a constant offset</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ft</em>&nbsp;</td><td>The <a class="el" href="structcomplexwf__t.html">complexwf_t</a> encoded fourier transform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq</em>&nbsp;</td><td>The returned frequency (p1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tdecay</em>&nbsp;</td><td>The returned tdecay (p2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>p0 (amplitude of powerspectrum ) of the fit ( can be NULL if not interested ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>p3 (offset) of the fit ( can be NULL if not interested )</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="fit__fft_8c-source.html#l00148">148</a> of file <a class="el" href="fit__fft_8c-source.html">fit_fft.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="fit__fft_8c-source.html#l00072">fit_fft_prepare()</a>, <a class="el" href="bpm__wf_8h-source.html#l00190">complexwf_t::fs</a>, <a class="el" href="bpm__wf_8h-source.html#l00189">complexwf_t::ns</a>, and <a class="el" href="bpm__wf_8h-source.html#l00191">complexwf_t::wf</a>.</p>

<p>Referenced by <a class="el" href="process__caltone_8c-source.html#l00011">process_caltone()</a>, and <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb0f5fd9a629e07038d336c0aad2cf41c"></a><!-- doxytag: member="bpm_process.h::check_saturation" ref="gb0f5fd9a629e07038d336c0aad2cf41c" args="(doublewf_t *w, int nbits, int *iunsat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int check_saturation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iunsat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks the saturation, so computes the first sample where no saturation occurs. If no saturation occurred in the waveform, this sample - stored in iunsat - will be set to 0. A saturated sample is found when it's ADC value is more (resp. less) than then maximum allowed ADC value ( 2^nbits ) minus a threshold set to 15. ( resp. the minium allowed ADC value, being 0 ) plus a threshold set to 15.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>The waveform contained in the <a class="el" href="structdoublewf__t.html">doublewf_t</a> SHOULD NOT have been pedestal corrected. This routine will assume the waveform runs between 0 and 2^nbits.</dd></dl>
Note the return code of the routine is slightly different than whan is conventional in libbpm since I wanted to encode whether saturation was found or not as the return code of the routine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The waveform to check, encoded as a <a class="el" href="structdoublewf__t.html">doublewf_t</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbits</em>&nbsp;</td><td>The number of digitiser bits (e.g. 12 or 14 ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iunsat</em>&nbsp;</td><td>The returned last unsaturated sample</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 when saturation was present, 0 when not, -1 when failure occurred </dd></dl>

<p>Definition at line <a class="el" href="check__saturation_8c-source.html#l00011">11</a> of file <a class="el" href="check__saturation_8c-source.html">check_saturation.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__wf_8h-source.html#l00175">doublewf_t::ns</a>, and <a class="el" href="bpm__wf_8h-source.html#l00177">doublewf_t::wf</a>.</p>

<p>Referenced by <a class="el" href="process__caltone_8c-source.html#l00011">process_caltone()</a>, and <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9153adcd6718410b99010b3ad3209edb"></a><!-- doxytag: member="bpm_process.h::downmix_waveform" ref="g9153adcd6718410b99010b3ad3209edb" args="(doublewf_t *w, double frequency, complexwf_t *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int downmix_waveform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexwf__t.html">complexwf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Downmixes the input waveform agains a complex LO using a frequency f and phase 0, the real part of the resulting complex waveform was mixed against a cosine-like wave, the imaginary part against a sinus-like. Note that this is just the downmixing itself, no filtering whatsoever is applied here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The input waveform, encoded as a <a class="el" href="structdoublewf__t.html">doublewf_t</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq</em>&nbsp;</td><td>The frequency of the digital LO </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>The complex output downmixed waveform</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure. </dd></dl>

<p>Definition at line <a class="el" href="downmix__waveform_8c-source.html#l00010">10</a> of file <a class="el" href="downmix__waveform_8c-source.html">downmix_waveform.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__wf_8h-source.html#l00176">doublewf_t::fs</a>, <a class="el" href="bpm__nr_8h-source.html#l00208">complex_t::im</a>, <a class="el" href="bpm__wf_8h-source.html#l00175">doublewf_t::ns</a>, <a class="el" href="bpm__nr_8h-source.html#l00207">complex_t::re</a>, <a class="el" href="bpm__wf_8h-source.html#l00177">doublewf_t::wf</a>, and <a class="el" href="bpm__wf_8h-source.html#l00191">complexwf_t::wf</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4d5ba258550486446e98b18b06d793f9"></a><!-- doxytag: member="bpm_process.h::ddc_waveform" ref="g4d5ba258550486446e98b18b06d793f9" args="(doublewf_t *w, double frequency, filter_t *filt, complexwf_t *dc, doublewf_t *buf_re, doublewf_t *buf_im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int ddc_waveform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfilter__t.html">filter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>filt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexwf__t.html">complexwf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>buf_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>buf_im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
As this is a pure wrapper around the ddc routine out of the dsp packate, please see the documentation there. 
<p>Definition at line <a class="el" href="ddc__waveform_8c-source.html#l00012">12</a> of file <a class="el" href="ddc__waveform_8c-source.html">ddc_waveform.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, and <a class="el" href="ddc_8c-source.html#l00078">ddc()</a>.</p>

<p>Referenced by <a class="el" href="process__caltone_8c-source.html#l00011">process_caltone()</a>, and <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gddd40cf316f88ea006e2e68424cb6987"></a><!-- doxytag: member="bpm_process.h::ddc_sample_waveform" ref="gddd40cf316f88ea006e2e68424cb6987" args="(doublewf_t *w, double frequency, filter_t *filt, int iSample, double t0, double tdecay, double *amp, double *phase, doublewf_t *buf_re, doublewf_t *buf_im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int ddc_sample_waveform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfilter__t.html">filter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>filt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iSample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tdecay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>buf_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>buf_im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TO BE IMPLEMENTED !!!<p>
This routine will contain a quicker version of the ddc algorithm that doesn't filter the entire waveform and only applies the filter at the sampling point. However, I need to make custom a apply_filter routine which is universally valid for all types of filters (IIR as well). 
<p>Definition at line <a class="el" href="ddc__sample__waveform_8c-source.html#l00019">19</a> of file <a class="el" href="ddc__sample__waveform_8c-source.html">ddc_sample_waveform.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>.</p>

<p>Referenced by <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gbbcbc20893990f64b46cfde9c823c4aa"></a><!-- doxytag: member="bpm_process.h::get_pedestal" ref="gbbcbc20893990f64b46cfde9c823c4aa" args="(doublewf_t *wf, int range, double *offset, double *rms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int get_pedestal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the mean pedestal using the first 20 (or how ever many are required) sample values, store the results in the offset and rms. This routine in fact just calls the doublewf_basic_stats routine and gets the appropriate values from the <a class="el" href="structwfstat__t.html">wfstat_t</a> structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wf</em>&nbsp;</td><td>The signal encoded as a <a class="el" href="structdoublewf__t.html">doublewf_t</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>The maximum sample to go to average over. The pedestal gets determined from the first "range" samples of the waveform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*offset</em>&nbsp;</td><td>Returns the mean value of the samples, so voltage offset (pedestal value) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*rms</em>&nbsp;</td><td>Returns the RMS on that</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="get__pedestal_8c-source.html#l00010">10</a> of file <a class="el" href="get__pedestal_8c-source.html">get_pedestal.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="doublewf_8c-source.html#l00467">doublewf_basic_stats()</a>, <a class="el" href="bpm__wf_8h-source.html#l00201">wfstat_t::mean</a>, and <a class="el" href="bpm__wf_8h-source.html#l00202">wfstat_t::rms</a>.</p>

<p>Referenced by <a class="el" href="get__t0_8c-source.html#l00046">get_t0()</a>, <a class="el" href="process__caltone_8c-source.html#l00011">process_caltone()</a>, and <a class="el" href="process__waveform_8c-source.html#l00012">process_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gac8e6d526cd906365ad1fa23f07b865d"></a><!-- doxytag: member="bpm_process.h::get_t0" ref="gac8e6d526cd906365ad1fa23f07b865d" args="(doublewf_t *w, double *t0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int get_t0           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdoublewf__t.html">doublewf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>t0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the t0 value from a diode peak, used in the case of internall triggering when a trigger pulse needs to be specified to calculate beam arrival<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>This routine needs some optimisation in terms of speed and some general checking in terms of correctness. Probably some re-writing using the bpmwf structures would be good...</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>A pointer to the <a class="el" href="structdoublewf__t.html">doublewf_t</a> signal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>returns t0</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="get__t0_8c-source.html#l00046">46</a> of file <a class="el" href="get__t0_8c-source.html">get_t0.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, <a class="el" href="bpm__interface_8h-source.html#l00308">bpm_verbose</a>, <a class="el" href="bpm__warning_8c-source.html#l00009">bpm_warning()</a>, <a class="el" href="bpm__wf_8h-source.html#l00176">doublewf_t::fs</a>, <a class="el" href="get__pedestal_8c-source.html#l00010">get_pedestal()</a>, <a class="el" href="nr__fit_8c-source.html#l00027">nr_fit()</a>, <a class="el" href="bpm__wf_8h-source.html#l00175">doublewf_t::ns</a>, and <a class="el" href="bpm__wf_8h-source.html#l00177">doublewf_t::wf</a>.</p>

<p>Referenced by <a class="el" href="fit__diodepulse_8c-source.html#l00010">fit_diodepulse()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd7417582fb39b8f0cd38a4e28618bf2b"></a><!-- doxytag: member="bpm_process.h::get_IQ" ref="gd7417582fb39b8f0cd38a4e28618bf2b" args="(double amp, double phase, double refamp, double refphase, double *Q, double *I)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int get_IQ           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>refamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>refphase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>I</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the I and Q from the amplitude and phase of the waveform and it's respective references. The I and Q are calculated respectively as : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ I = \frac{A}{A_{ref}} \cos( \phi - \phi_{ref} ) \]" src="form_6.png">
<p>
 and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = \frac{A}{A_{ref}} \sin( \phi - \phi_{ref} ) \]" src="form_7.png">
<p>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>amp</em>&nbsp;</td><td>The amplitude of the considered waveform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phase</em>&nbsp;</td><td>The phase of the considered waveform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refamp</em>&nbsp;</td><td>The amplitude of the reference cavity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refphase</em>&nbsp;</td><td>The phase of the reference cavity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>The returned Q value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I</em>&nbsp;</td><td>The returned I value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="get__IQ_8c-source.html#l00008">8</a> of file <a class="el" href="get__IQ_8c-source.html">get_IQ.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>, and <a class="el" href="bpm__warning_8c-source.html#l00009">bpm_warning()</a>.</p>

<p>Referenced by <a class="el" href="postprocess__waveform_8c-source.html#l00010">postprocess_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6906c83d2017b8c2536b31881155e8a6"></a><!-- doxytag: member="bpm_process.h::get_pos" ref="g6906c83d2017b8c2536b31881155e8a6" args="(double Q, double I, double IQphase, double posscale, double *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int get_pos           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>IQphase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>posscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the beam given I and Q values, IQphase and scale, it is calcualted as<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = c \left[ I \cos (\phi_{IQ} ) + Q \sin ( \phi_IQ )\right] \]" src="form_8.png">
<p>
<p>
Where c is the positionscale and x the position.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>The Q value (obtained from get_IQ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I</em>&nbsp;</td><td>The I value (obtained from get_IQ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IQphase</em>&nbsp;</td><td>The IQ phase rotation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>posscale</em>&nbsp;</td><td>The position scale </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The returned position</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="get__pos_8c-source.html#l00008">8</a> of file <a class="el" href="get__pos_8c-source.html">get_pos.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>.</p>

<p>Referenced by <a class="el" href="postprocess__waveform_8c-source.html#l00010">postprocess_waveform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4010b123b9d6424c97ea9ea77b7a8e4d"></a><!-- doxytag: member="bpm_process.h::get_slope" ref="g4010b123b9d6424c97ea9ea77b7a8e4d" args="(double Q, double I, double IQphase, double slopescale, double *slope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN int get_slope           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>IQphase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>slopescale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>slope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the beam slope given I and Q values, IQphase and scale, it is calcualted as<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = c \left[ - I \sin (\phi_{IQ} ) + Q \cos ( \phi_IQ )\right] \]" src="form_9.png">
<p>
<p>
Where c is the positionscale and x the position.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>The Q value (obtained from get_IQ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I</em>&nbsp;</td><td>The I value (obtained from get_IQ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IQphase</em>&nbsp;</td><td>The IQ phase rotation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slopescale</em>&nbsp;</td><td>The slope scale </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slope</em>&nbsp;</td><td>The returned slope</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BPM_SUCCESS upon success, BPM_FAILURE upon failure </dd></dl>

<p>Definition at line <a class="el" href="get__slope_8c-source.html#l00008">8</a> of file <a class="el" href="get__slope_8c-source.html">get_slope.c</a>.</p>

<p>References <a class="el" href="bpm__error_8c-source.html#l00009">bpm_error()</a>.</p>

<p>Referenced by <a class="el" href="postprocess__waveform_8c-source.html#l00010">postprocess_waveform()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 25 17:32:49 2008 for libbpm by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
